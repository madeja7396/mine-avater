# エージェント開発ハーネス設計書（1枚）

**目的**
「アバタ動画生成（喋ってる風）」の開発を、**複数LLMエージェントの並列実装**で加速する。止まりがちな自律作業を、**タスクロック + 強い検証（テスト）+ 収束用CI**で“回り続ける”形にする。着想元：Anthropicの「Cコンパイラをエージェントチームで実装」事例（Claude）。

---

## 0. 成果物の定義

* **最終成果物**：`avatar_pipeline` が指定入力（音声/画像）から、自分のデジタルクローンで自然な動画生成を実現し、PSNR/SSIMスコアを10-20%向上させること.
* **品質の“機械判定”**（人間レビュー依存を減らす）

  * **リップシンク誤差**（音素/口形のズレ）
  * **顔/口周りの破綻検出**（フレーム間不連続、口領域の崩れ）
  * **時間的一貫性**（チャンク境界で表情/声質が急変しない）
  * **処理健全性**（OOM率、速度、失敗率）

---

## 1. 全体アーキテクチャ（最小構成）

**中核思想：プロンプトより検証器。** エージェントは「正しいゴール」をテストで学習させる。

* **共有Git（bare）**：単一の真実（SSOT）
* **N個のエージェントコンテナ**：各自 `clone → task lock → implement → run tests → push`
* **CI/ローカル検証スクリプト**：`fast` と `full` を分離（決定的サブサンプル）
* **ログ収集**：LLMが読める短い要約 + 詳細ログはファイル化

---

## 2. リポジトリ構造（推奨）

```
repo/
  current_tasks/            # ロック用（git管理）
  specs/                    # SSOT仕様（入力/出力/品質定義）
  harness/                  # エージェント実行ハーネス（スクリプト）
  pipeline/                 # 実装（前処理→生成→後処理）
  eval/
    fast/                   # 1%〜10%決定サンプル（seed固定）
    full/                   # 重いが決定的
  ci/                       # GitHub Actions等
  logs/                     # 人間用（CIで要約生成）
```

---

## 3. タスク分割と同期（タスクロック方式）

### 3.1 タスク粒度（並列が効く粒度にする）

* **独立に進められる単位**へ分割（例：`mouth_roi_stabilize`, `phoneme_align`, `frame_blend`, `post_denoise`, `export_mux`）
* 「巨大で単一の塊」は並列が死ぬので、**先に“切断点（インタフェース）”を作る**

  * 例：`audio_features.npy`, `mouth_landmarks.json`, `frames/` を中間成果物として固定

### 3.2 ロック（原始だが強い）

* 取得：`current_tasks/<task>.lock` を作ってpushできた者が担当
* 失敗時：エージェントが `lock` を解放しないケースがあるので、**TTL（期限）**を別ファイルに書く

  * `current_tasks/<task>.lock.meta` に `owner`, `timestamp`, `ttl_minutes`
* 競合：マージコンフリクトは許容（ただし**ロックファイルは絶対に手編集しない**）

---

## 4. 検証（テスト）設計：fast / full / oracle

### 4.1 fast（常時）

* **決定的サブサンプル**：固定seedでテストデータの1%〜10%を選ぶ
* 目的：回帰を最速検出、LLMが“試行回数”を増やせるようにする

### 4.2 full（収束フェーズ）

* `fast` が緑のPRのみ `full` を回す
* 終盤は「新機能が既存を壊す」が増えるので、**CIを強くするほど生産性が上がる**（逆説）

### 4.3 oracle（塊タスク対策）

* 既知安定版（baseline）を「オラクル」にして差分比較

  * 例：新しい口形推定だけ差し替えて、他はbaseline固定
* “どこで壊れたか”を機械的に絞る（デルタデバッグ発想）

---

## 5. ログ設計（LLMが読める形に最適化）

* CI出力は短く：**先頭にサマリ行**を必ず出す

  * 例：`ERROR: lipsync_mae=0.183 > 0.120 (sample=fast_003, frame=812)`
* 詳細は `logs/<run_id>/...` へ退避し、CIには**パスと要点だけ**を出す
* すべてgrep可能に（`ERROR:`, `WARN:`, `METRIC:` プレフィクス固定）

---

## 6. エージェント役割（職能分割で衝突を減らす）

* **Implementer**：機能実装・バグ修正
* **Verifier**：テスト追加、失敗モードの形式化（最重要）
* **Refactorer**：重複排除、インタフェース整備、収束させる係
* **CI/SRE**：fast/full設計、ログ整形、実行時間短縮
* **Doc/SSOT**：`specs/` の更新、タスク定義の品質維持

---

## 7. 安全策（必須）

* **コンテナ隔離 + リソース制限**（CPU/GPU/メモリ上限）
* 破壊コマンド禁止（`rm -rf /`系）。ワークスペースは使い捨て
* 秘密情報をrepoに置かない（HFトークン等は注入方式）
* “止まらないループ”は便利だが危険：**監視プロセス**で異常終了/暴走を検知

---

## 8. 運用手順（最小で回る）

1. 人間が `specs/quality.md` と `eval/fast` を整備（最初にここへ投資）
2. `current_tasks/` にタスクを投入（粒度は小さめ）
3. エージェントはロック取得→実装→`make test_fast`→push
4. CIが `test_fast` を通したPRのみ `test_full` に進める
5. 収束フェーズ：タスクを「実装」から「回帰削減」「切り分け（oracle）」へ移す

---

## 成功条件（この方式が“勝つ”条件）

* **テストが強い**（仕様が曖昧でも、検証器がゴールを固定できる）
* タスクが**独立**している（または oracle で擬似独立化できる）
* ログが**短く・決定的**（LLMが迷わない）

この1枚を土台に、次にやるべきは「eval/fast の最初の10本（決定的）」と「中間成果物インタフェースの固定」。ここが決まると、エージェントは“それっぽい努力”ではなく“正しい努力”をし始める。
